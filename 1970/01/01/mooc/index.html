<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>v-show和 v-if 区别 | 记录</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.07207228.css" as="style"><link rel="preload" href="/assets/js/app.d901bced.js" as="script"><link rel="preload" href="/assets/js/9.f70bb51d.js" as="script"><link rel="preload" href="/assets/js/4.04f9b0a3.js" as="script"><link rel="preload" href="/assets/js/22.fa8d8bd5.js" as="script"><link rel="preload" href="/assets/js/10.6c07ca04.js" as="script"><link rel="prefetch" href="/assets/js/11.ded4fa08.js"><link rel="prefetch" href="/assets/js/12.1566e8e9.js"><link rel="prefetch" href="/assets/js/13.8ebadafa.js"><link rel="prefetch" href="/assets/js/14.2eae6fcb.js"><link rel="prefetch" href="/assets/js/15.c3b09a13.js"><link rel="prefetch" href="/assets/js/16.82983314.js"><link rel="prefetch" href="/assets/js/17.e4d9cc9a.js"><link rel="prefetch" href="/assets/js/18.59d74889.js"><link rel="prefetch" href="/assets/js/19.a44f1b3b.js"><link rel="prefetch" href="/assets/js/20.59422492.js"><link rel="prefetch" href="/assets/js/21.3975ae56.js"><link rel="prefetch" href="/assets/js/23.779af9e6.js"><link rel="prefetch" href="/assets/js/24.f87843ba.js"><link rel="prefetch" href="/assets/js/25.f7a5d2f5.js"><link rel="prefetch" href="/assets/js/26.3b6b0728.js"><link rel="prefetch" href="/assets/js/27.78ee38f2.js"><link rel="prefetch" href="/assets/js/28.cadc989a.js"><link rel="prefetch" href="/assets/js/29.d4a4f211.js"><link rel="prefetch" href="/assets/js/3.b14bc519.js"><link rel="prefetch" href="/assets/js/30.53680683.js"><link rel="prefetch" href="/assets/js/31.2da0dfc8.js"><link rel="prefetch" href="/assets/js/32.52a3bbdb.js"><link rel="prefetch" href="/assets/js/33.a7e071b3.js"><link rel="prefetch" href="/assets/js/34.d2dfc4ee.js"><link rel="prefetch" href="/assets/js/35.08756908.js"><link rel="prefetch" href="/assets/js/36.f340a051.js"><link rel="prefetch" href="/assets/js/37.167fee8d.js"><link rel="prefetch" href="/assets/js/38.54b353a3.js"><link rel="prefetch" href="/assets/js/39.be2bf926.js"><link rel="prefetch" href="/assets/js/40.813518ee.js"><link rel="prefetch" href="/assets/js/41.7c06cc03.js"><link rel="prefetch" href="/assets/js/42.d860adcc.js"><link rel="prefetch" href="/assets/js/43.39f8f3b7.js"><link rel="prefetch" href="/assets/js/5.569dcaa8.js"><link rel="prefetch" href="/assets/js/6.571a211f.js"><link rel="prefetch" href="/assets/js/7.86d3a8a9.js"><link rel="prefetch" href="/assets/js/8.3f185511.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.cac334c8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.07207228.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><div><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">记录 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/list/" class="nav-link">文档</a></li><li class="nav-item"><a href="/tag/" class="nav-link">标签</a></li><li class="nav-item"><a href="https://github.com/sogud" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">记录 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/list/" class="nav-link">文档</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">标签</a></li><li class="mobile-nav-item"><a href="https://github.com/sogud" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        
      </h1> <div class="post-meta"><!----> <!----> <!----></div></header> <div itemprop="articleBody" class="content__default"><h3 id="v-show和-v-if-区别"><a href="#v-show和-v-if-区别" class="header-anchor">#</a> v-show和 v-if 区别</h3> <p>v-if控制组件是否渲染，v-show 控制组件 css的display样式。</p> <p>v-if会存在不会存在dom中，v-if会一直存在dom中。</p> <h3 id="为何-v-for中要有key"><a href="#为何-v-for中要有key" class="header-anchor">#</a> 为何 v-for中要有key</h3> <p>官方文档回答：<code>key</code> 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p> <p>有相同父元素的子元素必须有<strong>独特的 key</strong>。重复的 key 会造成渲染错误。</p> <p>使用<code>id</code>的效率会比index的效率高，如在中间插入一条新数据，<code>index</code>会重新排序，<code>id</code>会保持不变。</p> <p>此时更新渲染数据,通过<code>index</code>定义的<code>key</code>去进行前后数据的对比,发现</p> <div class="language- extra-class"><pre class="language-text"><code>之前的数据                         之后的数据

key: 0  index: 0 name: test1     key: 0  index: 0 name: test1
key: 1  index: 1 name: test2     key: 1  index: 1 name: 我是插队的那条数据
key: 2  index: 2 name: test3     key: 2  index: 2 name: test2
                                 key: 3  index: 3 name: test3
复制代码
</code></pre></div><p>通过上面清晰的对比,发现除了第一个数据可以复用之前的之外,另外三条数据都需要重新渲染;</p> <p>是不是很惊奇,我明明只是插入了一条数据,怎么三条数据都要重新渲染?而我想要的只是新增的那一条数据新渲染出来就行了</p> <p>最好的办法是使用数组中不会变化的那一项作为<code>key</code>值,对应到项目中,即每条数据都有一个唯一的<code>id</code>,来标识这条数据的唯一性;使用<code>id</code>作为<code>key</code>值,我们再来对比一下向中间插入一条数据,此时会怎么去渲染</p> <div class="language- extra-class"><pre class="language-text"><code>之前的数据                              之后的数据

key: 1  id: 1 index: 0 name: test1     key: 1  id: 1 index: 0  name: test1
key: 2  id: 2 index: 1 name: test2     key: 4  id: 4 index: 1  name: 我是插队的那条数据
key: 3  id: 3 index: 2 name: test3     key: 2  id: 2 index: 2  name: test2
                                       key: 3  id: 3 index: 3  name: test3
</code></pre></div><p>同理在react中使用map渲染列表时,也是必须加key,且推荐做法也是使用<code>id</code>,也是这个原因。</p> <p><a href="https://juejin.im/post/5aae19aa6fb9a028d4445d1a" target="_blank" rel="noopener noreferrer">参考连接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="描述vue组件生命周期-有父子组件情况"><a href="#描述vue组件生命周期-有父子组件情况" class="header-anchor">#</a> 描述vue组件生命周期(有父子组件情况)</h3> <p><code>beforeCreate</code> <code>Created</code></p> <p><code>beforeMount</code> <code>mounted</code></p> <p><code>beforeUpdate</code> <code>updated</code></p> <p><code>beforeDestroy</code> <code>destroyed</code></p> <p><code>activated</code> <code>deactivated</code></p> <p><code>errorCaptured</code></p> <p>正常8个，keep-alive 2个，捕获子组件错误1个(2.5新增)。</p> <h3 id="vue组件如何通讯"><a href="#vue组件如何通讯" class="header-anchor">#</a> vue组件如何通讯</h3> <p><code>Props</code> <code>vuex</code> <code>new Bus</code> <code>provide inject</code> <code>$parent $children</code></p> <h3 id="描述组件渲染和更新过程"><a href="#描述组件渲染和更新过程" class="header-anchor">#</a> 描述组件渲染和更新过程</h3> <p>渲染组件时，会通过<code>Vue.extend</code>方法构建子组件的构造函数，并进行实例化。最终手动调用<code>$mount()</code>进行挂载。更新组件时会进行<code>patchVnode</code>流程.核心就是diff算法.</p> <p>当数据发生变化的时候，会触发渲染 <code>watcher</code> 的回调函数，进而执行组件的更新过程</p> <h3 id="双向数据绑定和-v-model的实现原理"><a href="#双向数据绑定和-v-model的实现原理" class="header-anchor">#</a> 双向数据绑定和 v-model的实现原理</h3> <p>依赖收集：收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理，我们把这个过程叫派发更新，其实 <code>Watcher</code> 和 <code>Dep</code> 就是一个非常经典的观察者设计模式的实现</p> <p>派发更新：实际上就是当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 <code>watcher</code>，都触发它们的 <code>update</code> 过程，这个过程又利用了队列做了进一步优化，在 <code>nextTick</code> 后执行所有 <code>watcher</code> 的 <code>run</code>，最后执行它们的回调函数。</p> <h3 id="vue-渲染过程"><a href="#vue-渲染过程" class="header-anchor">#</a> vue 渲染过程</h3> <ol><li><p>new Vue，执行初始化，将传入的data数据绑定到当前实例，就可以通过this.message的形式访问传入的数据。这个过程是执行initData()函数完成的。</p></li> <li><p>挂载$mount方法，通过自定义Render方法、template、el等生成Render函数。如果传入了模版(template)就将模版里面的内容编译成render函数，否则将传入的el对应的元素的内容编译成render函数。编译是调用compileToFunctions函数完成的。也可以自己手写render函数，可以减少编译这一环节。其中render渲染函数的优先级最高，template次之且需编译成渲染函数，而挂载点el属性对应的元素若存在，则在前两者均不存在时，其outerHTML才会用于编译与渲染。</p></li> <li><p>生成render函数后，调用_createElement函数生成vnode。</p></li> <li><p>将虚拟DOM映射为真实DOM页面上。</p></li></ol> <h3 id="react-组件如何通讯"><a href="#react-组件如何通讯" class="header-anchor">#</a> react 组件如何通讯</h3> <h3 id="jsx本质是什么"><a href="#jsx本质是什么" class="header-anchor">#</a> jsx本质是什么</h3> <ul><li><p>JSX是React引入的，但不是React独有的</p></li> <li><p>React已经将它作为一个独立标准开放，其他项目也可用</p></li> <li><p>React.createElement是可以自定义修改的</p></li> <li><p>本身功能已经完备，和其他标准兼容和扩展没问题</p> <p>和vue的rander函数很像，会编译成React.createElement方法，早期没有jsx使用这种方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 自定义组件jsx代码</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Input addTitle<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addTitle</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>List data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>list<span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 解析结果</span>
<span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">creatElement</span><span class="token punctuation">(</span>‘div’<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>Input<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">addTitle</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addTitle</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>List<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>list<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>

</code></pre></div></li></ul> <h3 id="context是什么-有什么用途"><a href="#context是什么-有什么用途" class="header-anchor">#</a> context是什么，有什么用途</h3> <h3 id="shouldcomponentupdate-的用途"><a href="#shouldcomponentupdate-的用途" class="header-anchor">#</a> shouldComponentUpdate 的用途</h3> <p>返回值 <code>Boolean</code>，用于优化组件。</p> <h3 id="描述redux-单项数据流"><a href="#描述redux-单项数据流" class="header-anchor">#</a> 描述redux 单项数据流</h3> <h3 id="setstete-是同步还是异步"><a href="#setstete-是同步还是异步" class="header-anchor">#</a> setStete 是同步还是异步</h3> <p>有同步也有异步，正常情况是异步，在setTim eout里又是同步，异步情况下，多个setState会被合并，函数不会被合并</p> <p><img src="mook.assets/image-20200527093948732.png" alt="image-20200527093948732"></p> <h3 id="基于react-vue设计一个todolist-组件结构-redux-state数据结构"><a href="#基于react-vue设计一个todolist-组件结构-redux-state数据结构" class="header-anchor">#</a> 基于react/vue设计一个todolist(组件结构，redux state数据结构)</h3> <h3 id="前端代码为何要构建打包"><a href="#前端代码为何要构建打包" class="header-anchor">#</a> 前端代码为何要构建打包</h3> <p><strong>一、webpack的打包原理</strong></p> <ol><li>识别入口文件</li> <li>通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖)</li> <li>webpack做的就是分析代码，转换代码，编译代码，输出代码</li> <li>最终形成打包后的代码</li></ol> <p><strong>二、什么是loader</strong></p> <p>loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</p> <ol><li>处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行</li> <li>第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码</li></ol> <p><strong>三、什么是plugin</strong></p> <p>在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。</p> <p><strong>四、loader和plugin的区别</strong></p> <p>对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程</p> <p>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</p> <h3 id="module-chunk-bundle分别是什么意思-有何区别"><a href="#module-chunk-bundle分别是什么意思-有何区别" class="header-anchor">#</a> module chunk bundle分别是什么意思，有何区别</h3> <p><img src="mook.assets/006tNc79ly1g3gc8q97lgj31hd0u07ek.jpg" alt="img"></p> <p>看这个图就很明白了：</p> <ol><li>对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 <strong>module</strong> ；</li> <li>当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 <strong>chunk</strong> 文件，webpack 会对这个 chunk 文件进行一些操作；</li> <li>webpack 处理好 chunk 文件后，最后会输出 <strong>bundle</strong> 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。</li></ol> <p>一般来说一个 chunk 对应一个 bundle，比如上图中的 <code>utils.js -&gt; chunks 1 -&gt; utils.bundle.js</code>；但也有例外，比如说上图中，我就用 <code>MiniCssExtractPlugin</code> 从 chunks 0 中抽离出了 <code>index.bundle.css</code> 文件。</p> <h3 id="一句话总结"><a href="#一句话总结" class="header-anchor">#</a> 一句话总结：</h3> <p>我们可以写多个module，打包过程生成一个或者多个chunks，打包结束后生成一个或多个bundle，与chunks对应。</p> <p><code>module</code>，<code>chunk</code> 和 <code>bundle</code> 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：</p> <p>我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。</p> <h3 id="loader和plugin-区别"><a href="#loader和plugin-区别" class="header-anchor">#</a> loader和plugin 区别</h3> <ul><li><p>相对于loader转换指定类型的模块功能，plugins能够被用于执行更广泛的任务比如打包优化、文件管理、环境注入等</p></li> <li><p>loader一般是将某个语法统一处理为统一的语法
plugin一般是在打包前或打包后对结果进行再次操作</p></li> <li><p>loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。</p></li> <li><p>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</p></li> <li><p>loader：webpack自身只支持js和json这两种格式的文件，对于其他文件需要通过loader将其转换为commonJS规范的文件后，webpack才能解析到
plugin：是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作</p></li> <li><p>loader是翻译官，plugin是干活滴</p></li></ul> <h3 id="webpack如何实现懒加载"><a href="#webpack如何实现懒加载" class="header-anchor">#</a> webpack如何实现懒加载</h3> <h3 id="webpack-常见性能优化"><a href="#webpack-常见性能优化" class="header-anchor">#</a> webpack 常见性能优化</h3> <h3 id="babel-runtime-和-babel-polyfill区别"><a href="#babel-runtime-和-babel-polyfill区别" class="header-anchor">#</a> babel-runtime 和 babel-polyfill区别</h3></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h3 active"><a href="#v-show和-v-if-区别" title="v-show和 v-if 区别">v-show和 v-if 区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#为何-v-for中要有key" title="为何 v-for中要有key">为何 v-for中要有key</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#描述vue组件生命周期-有父子组件情况" title="描述vue组件生命周期(有父子组件情况)">描述vue组件生命周期(有父子组件情况)</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#vue组件如何通讯" title="vue组件如何通讯">vue组件如何通讯</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#描述组件渲染和更新过程" title="描述组件渲染和更新过程">描述组件渲染和更新过程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#双向数据绑定和-v-model的实现原理" title="双向数据绑定和 v-model的实现原理">双向数据绑定和 v-model的实现原理</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#vue-渲染过程" title="vue 渲染过程">vue 渲染过程</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#react-组件如何通讯" title="react 组件如何通讯">react 组件如何通讯</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#jsx本质是什么" title="jsx本质是什么">jsx本质是什么</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#context是什么-有什么用途" title="context是什么，有什么用途">context是什么，有什么用途</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#shouldcomponentupdate-的用途" title="shouldComponentUpdate 的用途">shouldComponentUpdate 的用途</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#描述redux-单项数据流" title="描述redux 单项数据流">描述redux 单项数据流</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#setstete-是同步还是异步" title="setStete 是同步还是异步">setStete 是同步还是异步</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#基于react-vue设计一个todolist-组件结构-redux-state数据结构" title="基于react/vue设计一个todolist(组件结构，redux state数据结构)">基于react/vue设计一个todolist(组件结构，redux state数据结构)</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#前端代码为何要构建打包" title="前端代码为何要构建打包">前端代码为何要构建打包</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#module-chunk-bundle分别是什么意思-有何区别" title="module chunk bundle分别是什么意思，有何区别">module chunk bundle分别是什么意思，有何区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#一句话总结" title="一句话总结：">一句话总结：</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#loader和plugin-区别" title="loader和plugin 区别">loader和plugin 区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#webpack如何实现懒加载" title="webpack如何实现懒加载">webpack如何实现懒加载</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#webpack-常见性能优化" title="webpack 常见性能优化">webpack 常见性能优化</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#babel-runtime-和-babel-polyfill区别" title="babel-runtime 和 babel-polyfill区别">babel-runtime 和 babel-polyfill区别</a></div></div></div></div> <footer class="footer" data-v-246f3a3e><div class="footer-left-wrap" data-v-246f3a3e><ul class="links" data-v-246f3a3e><li class="links-item" data-v-246f3a3e><a href="/1970/01/01/mooc/github.com.html" class="nav-link" data-v-246f3a3e>GitHub</a></li><li class="links-item" data-v-246f3a3e><a href="/1970/01/01/mooc/github.com.html" class="nav-link" data-v-246f3a3e>Twitter</a></li></ul></div> <div class="footer-right-wrap" data-v-246f3a3e></div></footer></div></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.d901bced.js" defer></script><script src="/assets/js/9.f70bb51d.js" defer></script><script src="/assets/js/4.04f9b0a3.js" defer></script><script src="/assets/js/22.fa8d8bd5.js" defer></script><script src="/assets/js/10.6c07ca04.js" defer></script>
  </body>
</html>
