(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{556:function(t,e,a){"use strict";a.r(e);var s=a(11),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"v-show和-v-if-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-show和-v-if-区别"}},[t._v("#")]),t._v(" v-show和 v-if 区别")]),t._v(" "),a("p",[t._v("v-if控制组件是否渲染，v-show 控制组件 css的display样式。")]),t._v(" "),a("p",[t._v("v-if会存在不会存在dom中，v-if会一直存在dom中。")]),t._v(" "),a("h3",{attrs:{id:"为何-v-for中要有key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为何-v-for中要有key"}},[t._v("#")]),t._v(" 为何 v-for中要有key")]),t._v(" "),a("p",[t._v("官方文档回答："),a("code",[t._v("key")]),t._v(" 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。")]),t._v(" "),a("p",[t._v("有相同父元素的子元素必须有"),a("strong",[t._v("独特的 key")]),t._v("。重复的 key 会造成渲染错误。")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("id")]),t._v("的效率会比index的效率高，如在中间插入一条新数据，"),a("code",[t._v("index")]),t._v("会重新排序，"),a("code",[t._v("id")]),t._v("会保持不变。")]),t._v(" "),a("p",[t._v("此时更新渲染数据,通过"),a("code",[t._v("index")]),t._v("定义的"),a("code",[t._v("key")]),t._v("去进行前后数据的对比,发现")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("之前的数据                         之后的数据\n\nkey: 0  index: 0 name: test1     key: 0  index: 0 name: test1\nkey: 1  index: 1 name: test2     key: 1  index: 1 name: 我是插队的那条数据\nkey: 2  index: 2 name: test3     key: 2  index: 2 name: test2\n                                 key: 3  index: 3 name: test3\n复制代码\n")])])]),a("p",[t._v("通过上面清晰的对比,发现除了第一个数据可以复用之前的之外,另外三条数据都需要重新渲染;")]),t._v(" "),a("p",[t._v("是不是很惊奇,我明明只是插入了一条数据,怎么三条数据都要重新渲染?而我想要的只是新增的那一条数据新渲染出来就行了")]),t._v(" "),a("p",[t._v("最好的办法是使用数组中不会变化的那一项作为"),a("code",[t._v("key")]),t._v("值,对应到项目中,即每条数据都有一个唯一的"),a("code",[t._v("id")]),t._v(",来标识这条数据的唯一性;使用"),a("code",[t._v("id")]),t._v("作为"),a("code",[t._v("key")]),t._v("值,我们再来对比一下向中间插入一条数据,此时会怎么去渲染")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("之前的数据                              之后的数据\n\nkey: 1  id: 1 index: 0 name: test1     key: 1  id: 1 index: 0  name: test1\nkey: 2  id: 2 index: 1 name: test2     key: 4  id: 4 index: 1  name: 我是插队的那条数据\nkey: 3  id: 3 index: 2 name: test3     key: 2  id: 2 index: 2  name: test2\n                                       key: 3  id: 3 index: 3  name: test3\n")])])]),a("p",[t._v("同理在react中使用map渲染列表时,也是必须加key,且推荐做法也是使用"),a("code",[t._v("id")]),t._v(",也是这个原因。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.im/post/5aae19aa6fb9a028d4445d1a",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考连接"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"描述vue组件生命周期-有父子组件情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述vue组件生命周期-有父子组件情况"}},[t._v("#")]),t._v(" 描述vue组件生命周期(有父子组件情况)")]),t._v(" "),a("p",[a("code",[t._v("beforeCreate")]),t._v(" "),a("code",[t._v("Created")])]),t._v(" "),a("p",[a("code",[t._v("beforeMount")]),t._v(" "),a("code",[t._v("mounted")])]),t._v(" "),a("p",[a("code",[t._v("beforeUpdate")]),t._v(" "),a("code",[t._v("updated")])]),t._v(" "),a("p",[a("code",[t._v("beforeDestroy")]),t._v(" "),a("code",[t._v("destroyed")])]),t._v(" "),a("p",[a("code",[t._v("activated")]),t._v(" "),a("code",[t._v("deactivated")])]),t._v(" "),a("p",[a("code",[t._v("errorCaptured")])]),t._v(" "),a("p",[t._v("正常8个，keep-alive 2个，捕获子组件错误1个(2.5新增)。")]),t._v(" "),a("h3",{attrs:{id:"vue组件如何通讯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue组件如何通讯"}},[t._v("#")]),t._v(" vue组件如何通讯")]),t._v(" "),a("p",[a("code",[t._v("Props")]),t._v(" "),a("code",[t._v("vuex")]),t._v(" "),a("code",[t._v("new Bus")]),t._v(" "),a("code",[t._v("provide inject")]),t._v(" "),a("code",[t._v("$parent $children")])]),t._v(" "),a("h3",{attrs:{id:"描述组件渲染和更新过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述组件渲染和更新过程"}},[t._v("#")]),t._v(" 描述组件渲染和更新过程")]),t._v(" "),a("p",[t._v("渲染组件时，会通过"),a("code",[t._v("Vue.extend")]),t._v("方法构建子组件的构造函数，并进行实例化。最终手动调用"),a("code",[t._v("$mount()")]),t._v("进行挂载。更新组件时会进行"),a("code",[t._v("patchVnode")]),t._v("流程.核心就是diff算法.")]),t._v(" "),a("p",[t._v("当数据发生变化的时候，会触发渲染 "),a("code",[t._v("watcher")]),t._v(" 的回调函数，进而执行组件的更新过程")]),t._v(" "),a("h3",{attrs:{id:"双向数据绑定和-v-model的实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双向数据绑定和-v-model的实现原理"}},[t._v("#")]),t._v(" 双向数据绑定和 v-model的实现原理")]),t._v(" "),a("p",[t._v("依赖收集：收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理，我们把这个过程叫派发更新，其实 "),a("code",[t._v("Watcher")]),t._v(" 和 "),a("code",[t._v("Dep")]),t._v(" 就是一个非常经典的观察者设计模式的实现")]),t._v(" "),a("p",[t._v("派发更新：实际上就是当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 "),a("code",[t._v("watcher")]),t._v("，都触发它们的 "),a("code",[t._v("update")]),t._v(" 过程，这个过程又利用了队列做了进一步优化，在 "),a("code",[t._v("nextTick")]),t._v(" 后执行所有 "),a("code",[t._v("watcher")]),t._v(" 的 "),a("code",[t._v("run")]),t._v("，最后执行它们的回调函数。")]),t._v(" "),a("h3",{attrs:{id:"vue-渲染过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-渲染过程"}},[t._v("#")]),t._v(" vue 渲染过程")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("new Vue，执行初始化，将传入的data数据绑定到当前实例，就可以通过this.message的形式访问传入的数据。这个过程是执行initData()函数完成的。")])]),t._v(" "),a("li",[a("p",[t._v("挂载$mount方法，通过自定义Render方法、template、el等生成Render函数。如果传入了模版(template)就将模版里面的内容编译成render函数，否则将传入的el对应的元素的内容编译成render函数。编译是调用compileToFunctions函数完成的。也可以自己手写render函数，可以减少编译这一环节。其中render渲染函数的优先级最高，template次之且需编译成渲染函数，而挂载点el属性对应的元素若存在，则在前两者均不存在时，其outerHTML才会用于编译与渲染。")])]),t._v(" "),a("li",[a("p",[t._v("生成render函数后，调用_createElement函数生成vnode。")])]),t._v(" "),a("li",[a("p",[t._v("将虚拟DOM映射为真实DOM页面上。")])])]),t._v(" "),a("h3",{attrs:{id:"react-组件如何通讯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-组件如何通讯"}},[t._v("#")]),t._v(" react 组件如何通讯")]),t._v(" "),a("h3",{attrs:{id:"jsx本质是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsx本质是什么"}},[t._v("#")]),t._v(" jsx本质是什么")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("JSX是React引入的，但不是React独有的")])]),t._v(" "),a("li",[a("p",[t._v("React已经将它作为一个独立标准开放，其他项目也可用")])]),t._v(" "),a("li",[a("p",[t._v("React.createElement是可以自定义修改的")])]),t._v(" "),a("li",[a("p",[t._v("本身功能已经完备，和其他标准兼容和扩展没问题")]),t._v(" "),a("p",[t._v("和vue的rander函数很像，会编译成React.createElement方法，早期没有jsx使用这种方法。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 自定义组件jsx代码")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Input addTitle"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTitle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("List data"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 解析结果")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("creatElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("‘div’"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("addTitle")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTitle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("List"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("data")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"context是什么-有什么用途"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#context是什么-有什么用途"}},[t._v("#")]),t._v(" context是什么，有什么用途")]),t._v(" "),a("h3",{attrs:{id:"shouldcomponentupdate-的用途"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate-的用途"}},[t._v("#")]),t._v(" shouldComponentUpdate 的用途")]),t._v(" "),a("p",[t._v("返回值 "),a("code",[t._v("Boolean")]),t._v("，用于优化组件。")]),t._v(" "),a("h3",{attrs:{id:"描述redux-单项数据流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述redux-单项数据流"}},[t._v("#")]),t._v(" 描述redux 单项数据流")]),t._v(" "),a("h3",{attrs:{id:"setstete-是同步还是异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstete-是同步还是异步"}},[t._v("#")]),t._v(" setStete 是同步还是异步")]),t._v(" "),a("p",[t._v("有同步也有异步，正常情况是异步，在setTim eout里又是同步，异步情况下，多个setState会被合并，函数不会被合并")]),t._v(" "),a("p",[a("img",{attrs:{src:"mook.assets/image-20200527093948732.png",alt:"image-20200527093948732"}})]),t._v(" "),a("h3",{attrs:{id:"基于react-vue设计一个todolist-组件结构-redux-state数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于react-vue设计一个todolist-组件结构-redux-state数据结构"}},[t._v("#")]),t._v(" 基于react/vue设计一个todolist(组件结构，redux state数据结构)")]),t._v(" "),a("h3",{attrs:{id:"前端代码为何要构建打包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端代码为何要构建打包"}},[t._v("#")]),t._v(" 前端代码为何要构建打包")]),t._v(" "),a("p",[a("strong",[t._v("一、webpack的打包原理")])]),t._v(" "),a("ol",[a("li",[t._v("识别入口文件")]),t._v(" "),a("li",[t._v("通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖)")]),t._v(" "),a("li",[t._v("webpack做的就是分析代码，转换代码，编译代码，输出代码")]),t._v(" "),a("li",[t._v("最终形成打包后的代码")])]),t._v(" "),a("p",[a("strong",[t._v("二、什么是loader")])]),t._v(" "),a("p",[t._v("loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中")]),t._v(" "),a("ol",[a("li",[t._v("处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行")]),t._v(" "),a("li",[t._v("第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码")])]),t._v(" "),a("p",[a("strong",[t._v("三、什么是plugin")])]),t._v(" "),a("p",[t._v("在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。")]),t._v(" "),a("p",[a("strong",[t._v("四、loader和plugin的区别")])]),t._v(" "),a("p",[t._v("对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程")]),t._v(" "),a("p",[t._v("plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务")]),t._v(" "),a("h3",{attrs:{id:"module-chunk-bundle分别是什么意思-有何区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#module-chunk-bundle分别是什么意思-有何区别"}},[t._v("#")]),t._v(" module chunk bundle分别是什么意思，有何区别")]),t._v(" "),a("p",[a("img",{attrs:{src:"mook.assets/006tNc79ly1g3gc8q97lgj31hd0u07ek.jpg",alt:"img"}})]),t._v(" "),a("p",[t._v("看这个图就很明白了：")]),t._v(" "),a("ol",[a("li",[t._v("对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 "),a("strong",[t._v("module")]),t._v(" ；")]),t._v(" "),a("li",[t._v("当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 "),a("strong",[t._v("chunk")]),t._v(" 文件，webpack 会对这个 chunk 文件进行一些操作；")]),t._v(" "),a("li",[t._v("webpack 处理好 chunk 文件后，最后会输出 "),a("strong",[t._v("bundle")]),t._v(" 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。")])]),t._v(" "),a("p",[t._v("一般来说一个 chunk 对应一个 bundle，比如上图中的 "),a("code",[t._v("utils.js -> chunks 1 -> utils.bundle.js")]),t._v("；但也有例外，比如说上图中，我就用 "),a("code",[t._v("MiniCssExtractPlugin")]),t._v(" 从 chunks 0 中抽离出了 "),a("code",[t._v("index.bundle.css")]),t._v(" 文件。")]),t._v(" "),a("h3",{attrs:{id:"一句话总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一句话总结"}},[t._v("#")]),t._v(" 一句话总结：")]),t._v(" "),a("p",[t._v("我们可以写多个module，打包过程生成一个或者多个chunks，打包结束后生成一个或多个bundle，与chunks对应。")]),t._v(" "),a("p",[a("code",[t._v("module")]),t._v("，"),a("code",[t._v("chunk")]),t._v(" 和 "),a("code",[t._v("bundle")]),t._v(" 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：")]),t._v(" "),a("p",[t._v("我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。")]),t._v(" "),a("h3",{attrs:{id:"loader和plugin-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loader和plugin-区别"}},[t._v("#")]),t._v(" loader和plugin 区别")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("相对于loader转换指定类型的模块功能，plugins能够被用于执行更广泛的任务比如打包优化、文件管理、环境注入等")])]),t._v(" "),a("li",[a("p",[t._v("loader一般是将某个语法统一处理为统一的语法\nplugin一般是在打包前或打包后对结果进行再次操作")])]),t._v(" "),a("li",[a("p",[t._v("loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。")])]),t._v(" "),a("li",[a("p",[t._v("plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务")])]),t._v(" "),a("li",[a("p",[t._v("loader：webpack自身只支持js和json这两种格式的文件，对于其他文件需要通过loader将其转换为commonJS规范的文件后，webpack才能解析到\nplugin：是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作")])]),t._v(" "),a("li",[a("p",[t._v("loader是翻译官，plugin是干活滴")])])]),t._v(" "),a("h3",{attrs:{id:"webpack如何实现懒加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack如何实现懒加载"}},[t._v("#")]),t._v(" webpack如何实现懒加载")]),t._v(" "),a("h3",{attrs:{id:"webpack-常见性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-常见性能优化"}},[t._v("#")]),t._v(" webpack 常见性能优化")]),t._v(" "),a("h3",{attrs:{id:"babel-runtime-和-babel-polyfill区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel-runtime-和-babel-polyfill区别"}},[t._v("#")]),t._v(" babel-runtime 和 babel-polyfill区别")])])}),[],!1,null,null,null);e.default=n.exports}}]);